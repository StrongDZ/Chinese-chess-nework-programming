@startuml
title Play Game Sequence Diagram - Chinese Chess (TCP Socket)

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

actor User
participant "Client" as Client
participant "TCP Socket" as Socket
participant "Server" as Server
database "Database" as DB
participant "AI Engine" as AI

note over Client, Server
  TCP connection already established
  User is logged in with valid sessionID
end note

== Start Game - Select Mode ==
User -> Client: Click "Play Game"
activate Client

Client -> User: Show game mode selection:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ€¢ Play Normal Game\nâ€¢ Play Custom Game\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

User -> Client: Select game mode\n(Normal or Custom)

Client -> Client: Store selected mode:\ngameMode = "normal" / "custom"

== Choose Opponent Type ==
Client -> User: Show opponent options:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ€¢ Play with Human\nâ€¢ Play with AI\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

User -> Client: Select opponent type

alt Play Normal Game with Human
    Client -> User: Show match options:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ€¢ Match Random Player\nâ€¢ Challenge Ready Player\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    User -> Client: Select match type
    
    == Choose Time Mode ==
    Client -> User: Show time control options:\n- Bullet (1+0, 2+1)\n- Blitz (3+0, 5+0)\n- Rapid (10+0, 15+10)\n- Classical (30+0, no limit)
    
    User -> Client: Select time mode\n(e.g., "5+0 Blitz")
    
    Client -> Client: Create MatchRequestPacket:\n{type="MATCH_REQUEST",\nsessionID, userID,\nmode="normal",\nmatchType="random/challenge",\ntimeControl={time:5, increment:0}}
    
    Client -> Socket: send(MatchRequestPacket)
    activate Socket
    Socket -> Server: Forward packet
    deactivate Socket
    activate Server
    
    Server -> Server: Validate sessionID
    
    alt Invalid session
        Server -> Socket: send(ERROR_SESSION)
        activate Socket
        Socket -> Client: Forward error
        deactivate Socket
        Client -> User: Show "Session expired"
        deactivate Client
        
    else Valid session
        == Match Random Player ==
        alt Random Match
            Server -> DB: INSERT INTO waiting_players\n(userID, timeControl, timestamp)
            activate DB
            DB --> Server: Added to queue
            deactivate DB
            
            Server -> DB: SELECT * FROM waiting_players\nWHERE timeControl = ?\nAND userID != ?\nLIMIT 1
            activate DB
            
            alt No opponent available
                DB --> Server: Empty result
                deactivate DB
                
                Server -> Socket: send(WAITING_FOR_OPPONENT)
                activate Socket
                Socket -> Client: Forward status
                deactivate Socket
                
                Client -> User: Show "Searching for opponent..."\nwith loading spinner\nand [Cancel] button
                
                loop Check every 2 seconds
                    Server -> DB: SELECT * FROM waiting_players\nWHERE timeControl = ?
                    activate DB
                    
                    alt Opponent found
                        DB --> Server: Opponent matched
                        deactivate DB
                        
                        Server -> DB: DELETE FROM waiting_players\nWHERE userID IN (user1, user2)
                        activate DB
                        DB --> Server: Removed from queue
                        deactivate DB
                        
                        Server -> Server: Create game session:\ngameID = UUID()\nplayers = [user1, user2]\nrandomize colors
                        
                        Server -> Socket: send(MatchFoundPacket)
                        Socket -> Client: Forward match info
                        
                        note over Client
                          Jump to "Game Setup" section
                        end note
                    end
                end
                
            else Opponent available
                DB --> Server: Opponent found
                deactivate DB
                
                Server -> DB: DELETE FROM waiting_players\nWHERE userID IN (user1, user2)
                activate DB
                DB --> Server: Removed from queue
                deactivate DB
            end
            
        == Challenge Ready Player ==
        else Challenge Player
            Server -> DB: SELECT status FROM users\nWHERE userID = targetUserID
            activate DB
            
            alt Target player offline
                DB --> Server: status = 'OFFLINE'
                deactivate DB
                
                Server -> Socket: send(ERROR_PLAYER_OFFLINE)
                activate Socket
                Socket -> Client: Forward error
                deactivate Socket
                
                Client -> User: Show "Player is offline"
                
            else Target player online
                DB --> Server: status = 'ONLINE'
                deactivate DB
                
                Server -> Server: Create ChallengePacket:\n{type="CHALLENGE",\nfrom=userID,\ntimeControl, gameMode}
                
                Server -> Socket: send(ChallengePacket)\nto target player
                activate Socket
                Socket -> Client: Forward challenge
                deactivate Socket
                
                Client -> User: Show "Challenge sent\nWaiting for response..."
                
                == Target Player Response ==
                alt Challenge accepted
                    note right
                      Target player accepts
                    end note
                    
                    Server -> Socket: send(CHALLENGE_ACCEPTED)
                    Socket -> Client: Forward acceptance
                    
                    note over Client
                      Jump to "Game Setup" section
                    end note
                    
                else Challenge declined
                    Server -> Socket: send(CHALLENGE_DECLINED)
                    Socket -> Client: Forward decline
                    
                    Client -> User: Show "Challenge declined"
                    deactivate Client
                    
                else Timeout (30 seconds)
                    Server -> Socket: send(CHALLENGE_TIMEOUT)
                    Socket -> Client: Forward timeout
                    
                    Client -> User: Show "Challenge expired"
                    deactivate Client
                end
            end
        end
        
        == Game Setup ==
        Server -> Server: Create game session:\n{gameID, player1, player2,\ntimeControl, currentTurn='red',\nboard=INITIAL_BOARD,\nmoves=[], startTime=NOW()}
        
        Server -> DB: INSERT INTO active_games\n(gameID, player1_id, player2_id,\ntime_control, status='ACTIVE')
        activate DB
        DB --> Server: Game created
        deactivate DB
        
        Server -> Server: Create GameStartPacket:\n{status="GAME_START",\ngameID, opponentInfo,\nyourColor="red/black",\ntimeControl, board}
        
        Server -> Socket: send(GameStartPacket)\nto both players
        activate Socket
        Socket -> Client: Forward game start
        deactivate Socket
        
        Client -> Client: Initialize game:\n- Setup board UI\n- Start clocks\n- Load opponent info\n- Enable/disable controls
        
        Client -> User: Display game board:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n[Opponent: Player2 (1450)]\nâ±ï¸ 5:00  vs  5:00 â±ï¸\n[Board UI]\nYour turn: RED â™Ÿï¸\n[Resign] [Draw] [Chat]\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        == Game Loop ==
        loop Until game ends
            Server -> Server: Check current turn
            
            alt User's turn
                Server -> Socket: send(YOUR_TURN{remainingTime})
                activate Socket
                Socket -> Client: Notify turn
                deactivate Socket
                
                Client -> Client: Enable move input\nStart timer countdown
                
                Client -> User: Highlight "Your turn"\nShow valid moves on select
                
                User -> Client: Select piece\n(e.g., click on Cannon)
                
                Client -> Client: Calculate legal moves\nfor selected piece
                
                Client -> User: Highlight legal moves\n(green squares)
                
                User -> Client: Select destination square
                
                Client -> Client: Validate move locally:\n- Legal move?\n- Own piece?\n- In bounds?
                
                alt Invalid move (client check)
                    Client -> User: Show "Invalid move"\n(shake animation + red border)
                    note over Client
                      Loop back to piece selection
                    end note
                    
                else Valid move (client check)
                    Client -> Client: Create MovePacket:\n{type="MOVE",\ngameID, sessionID,\nfrom={x:7,y:1}, to={x:0,y:1},\ntimestamp=NOW(),\nremainingTime=285}
                    
                    Client -> Socket: send(MovePacket)
                    activate Socket
                    Socket -> Server: Forward move
                    deactivate Socket
                    
                    Server -> Server: Validate move (authoritative):\n- Legal move check\n- Turn validation\n- Not in check after move\n- Piece belongs to player
                    
                    alt Invalid move (server check)
                        Server -> Server: Create MoveRejectedPacket:\n{status="MOVE_REJECTED",\nreason="Illegal move"}
                        
                        Server -> Socket: send(MoveRejectedPacket)
                        activate Socket
                        Socket -> Client: Forward rejection
                        deactivate Socket
                        
                        Client -> User: Show "Move rejected: [reason]"\nRevert move animation
                        
                        note over Client
                          Loop back to piece selection
                        end note
                        
                    else Valid move (server check)
                        Server -> Server: Apply move to game state:\n- Update board\n- Record move in moves[]\n- Switch turn\n- Update timer\n- Increment move number
                        
                        Server -> DB: UPDATE active_games SET\nboard_state=?,\nmoves=?,\ncurrent_turn=?,\nupdate_time=NOW()
                        activate DB
                        DB --> Server: Updated
                        deactivate DB
                        
                        == Check Game End Conditions ==
                        Server -> Server: Evaluate position:\n- Checkmate?\n- Stalemate?\n- Insufficient material?\n- 50-move rule?\n- Repetition?
                        
                        alt Game continues
                            Server -> Server: Create MoveAcceptedPacket:\n{status="MOVE_ACCEPTED",\nfrom, to, capturedPiece,\nnewBoardState,\ncheck=true/false,\nnextTurn="black"}
                            
                            Server -> Socket: send(MoveAcceptedPacket)\nto current player
                            activate Socket
                            Socket -> Client: Forward acceptance
                            deactivate Socket
                            
                            Client -> Client: Update board UI:\n- Animate move\n- Remove captured piece\n- Play sound effect\n- Stop own timer
                            
                            Client -> User: Update board display\nShow "Opponent's turn"
                            
                            == Notify Opponent ==
                            Server -> Server: Create OpponentMovePacket:\n{type="OPPONENT_MOVE",\nfrom, to, capturedPiece,\nnewBoardState,\ncheck=true/false,\nremainingTime}
                            
                            Server -> Socket: send(OpponentMovePacket)\nto opponent
                            activate Socket
                            Socket -> Client: Forward to opponent
                            deactivate Socket
                            
                            Client -> Client: Update opponent's board:\n- Animate opponent move\n- Start own timer\n- Enable move input
                            
                            Client -> User: Show move animation\nNotification: "Opponent moved"\nSound alert
                            
                        else Game ends
                            Server -> Server: Determine result:\n- Winner/Loser\n- Reason (checkmate/timeout/resign)\n- ELO changes
                            
                            note over Server
                              Jump to "Game End" section
                            end note
                        end
                    end
                end
                
            else Opponent's turn
                Client -> User: Show "Opponent thinking..."\nTimer countdown for opponent
                
                note right
                  Wait for opponent move
                  or timeout
                end note
            end
            
            == Optional: Draw Offer ==
            alt User offers draw
                User -> Client: Click "Offer Draw"
                
                Client -> Socket: send(DRAW_OFFER{gameID})
                Socket -> Server: Forward offer
                
                Server -> Socket: send to opponent
                Socket -> Client: Notify opponent
                
                Client -> User: Show dialog:\n"Opponent offers draw\n[Accept] [Decline]"
                
                alt Opponent accepts
                    Server -> Server: End game with draw
                    note over Server
                      Jump to "Game End" section
                    end note
                    
                else Opponent declines
                    Server -> Socket: send(DRAW_DECLINED)
                    Socket -> Client: Forward decline
                    
                    Client -> User: Show "Draw declined"
                end
            end
            
            == Optional: Resign ==
            alt User resigns
                User -> Client: Click "Resign"
                
                Client -> Client: Show confirmation:\n"Are you sure?\nYou will lose this game."
                
                User -> Client: Click "Yes, Resign"
                
                Client -> Socket: send(RESIGN{gameID})
                Socket -> Server: Forward resign
                
                Server -> Server: End game:\nwinner = opponent\nreason = "resignation"
                
                note over Server
                  Jump to "Game End" section
                end note
            end
            
            == Timer Check ==
            alt Player's time runs out
                Server -> Server: Detect timeout:\nremainingTime <= 0
                
                Server -> Server: End game:\nwinner = opponent\nreason = "timeout"
                
                note over Server
                  Jump to "Game End" section
                end note
            end
        end
        
        == Game End ==
        Server -> Server: Calculate ELO changes:\nif winner:\n  winnerELO += K * (1 - expectedScore)\n  loserELO -= K * expectedScore\nwhere K=32, expectedScore=1/(1+10^(diff/400))
        
        Server -> DB: INSERT INTO game_history\n(gameID, player1_id, player2_id,\nresult, moves[], pgn,\nstart_time, end_time,\ntime_control)
        activate DB
        DB --> Server: Game saved
        deactivate DB
        
        Server -> DB: UPDATE users SET\nelo = ?,\ntotal_games = total_games + 1,\nwins/losses/draws += 1\nWHERE userID IN (player1, player2)
        activate DB
        DB --> Server: Stats updated
        deactivate DB
        
        Server -> DB: UPDATE user_stats SET\nlast_game = NOW()\nWHERE userID IN (player1, player2)
        activate DB
        DB --> Server: Updated
        deactivate DB
        
        Server -> DB: DELETE FROM active_games\nWHERE gameID = ?
        activate DB
        DB --> Server: Cleaned up
        deactivate DB
        
        Server -> Server: Create GameResultPacket:\n{status="GAME_END",\nresult="WIN/LOSS/DRAW",\nreason="checkmate/timeout/resign",\neloChange="+15/-15",\nnewELO=1465}
        
        Server -> Socket: send(GameResultPacket)\nto both players
        activate Socket
        Socket -> Client: Forward result
        deactivate Socket
        
        Client -> Client: Stop timers\nDisable move input\nSave game to local history
        
        Client -> User: Show result popup:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nðŸŽ‰ Victory! ðŸŽ‰\nCheckmate!\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nYour ELO: 1450 â†’ 1465 (+15)\nOpponent: Player2 (1465 â†’ 1450)\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n[Rematch] [Analyze] [Exit]
        
        deactivate Client
        deactivate Server
    end

else Play Normal Game with AI
    Client -> User: Show AI difficulty:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ€¢ Easy (ELO ~1000)\nâ€¢ Medium (ELO ~1400)\nâ€¢ Hard (ELO ~1800)\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    User -> Client: Select difficulty\n(e.g., "Medium")
    
    Client -> Client: Create StartAIGamePacket:\n{type="START_AI_GAME",\nsessionID, userID,\ndifficulty="medium",\nmode="normal"}
    
    Client -> Socket: send(StartAIGamePacket)
    activate Socket
    Socket -> Server: Forward packet
    deactivate Socket
    activate Server
    
    Server -> Server: Validate sessionID
    
    Server -> Server: Create game session:\ngameID = UUID()\nopponent = "AI_MEDIUM"
    
    Server -> AI: Initialize AI:\nai = XiangqiMediumAI()\ncolor = "black" (AI plays black)
    activate AI
    AI --> Server: AI ready
    deactivate AI
    
    Server -> DB: INSERT INTO active_games\n(gameID, player_id, ai_difficulty)
    activate DB
    DB --> Server: Game created
    deactivate DB
    
    Server -> Socket: send(AIGameStartPacket)
    activate Socket
    Socket -> Client: Forward game start
    deactivate Socket
    
    Client -> User: Display game board:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nOpponent: AI Medium (1400)\nYour color: RED â™Ÿï¸\n[Board UI]\nYour turn!\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    == AI Game Loop ==
    loop Until game ends
        alt User's turn
            User -> Client: Make move
            Client -> Socket: send(MovePacket)
            activate Socket
            Socket -> Server: Forward move
            deactivate Socket
            
            Server -> Server: Validate user move
            
            alt Valid move
                Server -> Server: Update game state
                
                Server -> Server: Check game end
                
                alt Game continues
                    Server -> Socket: send(MoveAccepted)
                    Socket -> Client: Forward acceptance
                    
                    Client -> User: Update board
                    
                    == AI's Turn ==
                    Server -> AI: Calculate AI move:\nai.get_move(board, 'black')
                    activate AI
                    
                    AI -> AI: Evaluate position:\n- Search depth 2-4\n- Minimax/alpha-beta\n- Positional evaluation
                    
                    AI --> Server: Return AI move:\n{from, to}
                    deactivate AI
                    
                    Server -> Server: Apply AI move\nUpdate game state
                    
                    Server -> Server: Check game end
                    
                    alt Game continues
                        Server -> Socket: send(AIMovePacket)
                        activate Socket
                        Socket -> Client: Forward AI move
                        deactivate Socket
                        
                        Client -> Client: Animate AI move
                        
                        Client -> User: Update board\nShow "AI moved [piece]"\nSound effect
                        
                    else Game ends
                        note over Server
                          Calculate result
                          Update ELO (vs AI)
                          Save game history
                          Jump to "Game End"
                        end note
                    end
                    
                else Game ends
                    note over Server
                      User won/lost/draw
                      Jump to "Game End"
                    end note
                end
            end
        end
    end
    
    Server -> Socket: send(GameResultPacket)
    Socket -> Client: Forward result
    
    Client -> User: Show result\nwith ELO change\n(playing AI affects rating)
    
    deactivate Client
    deactivate Server

else Play Custom Game
    note over Client
      Similar flow but with:
      - Custom board setup
      - Modified rules (if any)
      - Can play by self (no opponent)
      See "customizeBoard.puml" for setup details
    end note
    
    alt Play Custom with AI
        note right
          Same as "Normal with AI"
          but using custom board
        end note
        
    else Play Custom by Self
        Client -> User: Setup custom board\nEnable free move mode\nNo timer, no rules
        
        Client -> User: Practice mode:\nMove any piece freely\nTest positions\n[Save Position] [Load Position]
    end
end

@enduml
