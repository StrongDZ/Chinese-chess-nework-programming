\subsection{Game Play Flow}

This sequence diagram illustrates the main game play flow, including move execution, turn management, game termination through resignation, and draw request/response handling. The system uses optimistic updates on the client side and server-side validation to ensure game integrity.

\textbf{Move Execution:} When a player makes a move, \texttt{GamePanel} first validates the move locally using \texttt{GameState.isValidMove()} to provide immediate feedback. If valid, the move is sent through \texttt{NetworkManager} → \texttt{GameSender} → \texttt{SocketClient} to the server. The server's \texttt{handleMove()} validates that the player is in a game, checks that it is the player's turn using in-memory turn tracking (\texttt{current\_turn}), and routes the move through \texttt{GameController} → \texttt{GameService} → \texttt{GameRepository} to persist the move in MongoDB. The service calculates the new XFEN board state, builds a \texttt{Move} object with coordinates, piece information, and timestamp, and updates the game document with the move, new XFEN, next turn, and remaining time. If the move is invalid (e.g., not the player's turn), the server sends an \texttt{INVALID\_MOVE} message back to the client.

\textbf{Optimistic Updates and Turn Synchronization:} The server does not echo the \texttt{MOVE} message back to the sender, as the client has already updated the board locally (optimistic update). Instead, the server only sends the move to the opponent to synchronize their board. The server updates turn tracking for both players in memory (\texttt{sender.current\_turn} and \texttt{opponent.current\_turn}) to ensure accurate turn validation. For PvP games, the opponent receives the move and updates their board display. For AI games, the server generates and sends the AI's move separately.

\textbf{Game End Detection:} The server does not automatically check for win or draw conditions after each move. Game termination only occurs when explicitly triggered by: (1) a client sending \texttt{GAME\_END} (checkmate detected client-side), (2) a client sending \texttt{RESIGN}, (3) a client sending \texttt{DRAW\_RESPONSE} with acceptance, or (4) opponent disconnection (abandonment). This design places game state validation responsibility on the client while the server maintains authoritative move history and turn tracking.

\textbf{Resignation:} When a player clicks "Resign", \texttt{GamePanel} shows a confirmation dialog. Upon confirmation, the resignation request is sent through the network layers to the server. The server's \texttt{handleResign()} validates the player is in a game, calls \texttt{GameController.handleResign()} to end the game in the database with result determined by the opponent winning, updates player statistics and calculates Elo ratings (if rated game), and sends \texttt{GAME\_END} messages to both players with \texttt{win\_side} set to the opponent's username. Both clients display the game result (winner sees "You won", resigning player sees "You resigned"), and the server clears game state for both players.

\textbf{Draw Request and Response:} When a player offers a draw, the request is sent to the server, which forwards it to the opponent and updates the game document to mark the draw offer. The opponent receives the draw request through \texttt{GameHandler}, which displays a dialog with Accept/Decline options. If the opponent accepts, the server ends the game with result "draw" and termination "agreement", calculates Elo ratings (if rated), and sends \texttt{GAME\_END} messages to both players with \texttt{win\_side: "draw"}. Both clients display the draw result. If the opponent declines, the server clears the draw offer flag and forwards the decline response to the challenger, who sees a "Draw declined" message.

The game play system emphasizes client-side responsiveness through optimistic updates and local validation, while maintaining server-side authority for move persistence, turn validation, and game state management.


